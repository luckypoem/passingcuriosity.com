---
title      : "The Hydras: Improving the C/C++ Development Experience via GCC Static Analysis Plugins"
tags       : [lca2010, gcc, static analysis, plugins]
categories : [lca]
location   : Wellington, New Zealand
---

The Hydras: Improving the C/C++ Development Experience via GCC Static Analysis
Plugins by Taras Glek. Tara is a static analysis hacker at Mozilla who spends
his time working on static analysis and manipulation code. Hacks on GCC and
other non-Mozilla code.

[talk]: http://www.lca2010.org.nz/programme/schedule/view_talk/50151
[thur]: http://www.lca2010.org.nz/programme/schedule/thursday
[hydra]: https://developer.mozilla.org/En/Dehydra

In a stone age of software development: things have stayed pretty much the
same, tool wise, since the 1970. Writing code is like digging yourself into a
whole: the more you do, the bigger the problem. Using static analysis tools to
reduce the problem.

Closer cooperation between the different layers is the way out: more
communication about requirements, rather than guessing or forcing stuff onto
people.

Tiered: web, browser, compiler, operating system. 

Static analysis: treat your code as a data structure, not just a text file,
for non-compilation tasks.

Useful for:

- finding bugs in code
- generating bindings
- visualising the codebase
- getting rid of dead code

Many of the existing tools look for a large number of easy bugs (dereference
NULL) that are, to some extent, language bugs.

Using tools like SWIG often fails and people wind up writing their own special
purpose binding generator. Use static analysis framework to make things like
SWIG less fragile.

At Mozilla they have a morbid fascination with dead code. Compilers can't
completely eliminate dead code (virtual methods, for example, aren't dead).
Detected an entire component in Mozilla as dead (which was still being patched
and maintained, wasting engineering effort).

Why use GCC?
============

C++ is impossibly difficult to parse (2 years to write a parser that doesn't
work). Trivial integration with build system.

Incomplete alternatives:

- LLVM Clang (a year or two away from ready)
- Elsa (not compiler backend, so you aren't sure the AST is correct)

Started on Elsa (due to rumours of GCC's hideousness). 

GCC 4.5 allows for plugins: you can put your own code in the compiler. License
change to allow plugins; plugin API combined the best of the 3rd party plugin
patches. Wasn't permitted before because Stallman was worried about people
writing optimisation, etc plugins and selling them.

The Hydras, LLVM, milepost, etc.

GCC Static Analysis
===================

GCC has attributes that you can use to annotate pretty much any code.

Also has a pass manager. GCC was never structured as a proper compiler: read a
compiler textbook and look at GCC and you'll go what the hell? They've been
modifying it to be more like a real compiler.

GIMPLE: a lot like C, but has additions to support things for C++, Java,
Objective-C, etc C++ code is turned into GIMPLE which can then be analysed
more easily (as it's pretty much C).

The Hydras
==========

GCC Plugins for code analysis

Analyses expressed as JavaScript plugins (rather than a wacky limited DSL)

* Concise analyses
* Errors in analyses do not crash the compiler
* Easy to create complex data structures required for complex analyses

Dehydra
-------

What is the name? Google-able. Generated a call graph, once, of a function
into a call flow graph. The basic blocks in the flow graph are the heads.

A simplified scripting API for handling types, function bodies, declarations,
etc.

JSON-like (allows cycles, as it's a representation of the AST) "reflective"
representation of C++ objects.

Allows for concise scripts, gentle introduction to static analysis.

Treehydra
---------

Javascript binding to GCC's GIMPLE

Generated by Dehydra

Allows sophisticated "traditiona" static analyses

Looks like C without being C.

GCC's AST changes relatively 

Why is a browser vendor hacking GCC?
====================================

Why aren't there static analysis already? Mozilla is a big code base and
humans don't deal with millions of LOC very well. They're trying to speed up
their development process and thus need to increase developer leverage by
automation.

Mozilla is big and moving jast:

1.7 million lines of C++ and another million of Javascript.

Constantly being optimized for better performance, adding new features.

Use static analysis to generate 6MB patches which touched [maybe] every
function in Mozilla to switch from smart pointers to raw pointers in the
switch from reference counting to garbage collection (which got scrapped
because).

Understanding C++
=================

LXR is a very frustrating tool; it's basically a grep (that you can link to).

DXR is just like LXR but it has semantic information (types, etc.) It
understands macros and the like and understands subclassing, etc., etc.

Some IDEs can provide some of this stuff, but it's usually pretty rudimentary.

Another problem with C++ is that you wind up with a large number of methods
with the same name (`toString`). The easiest way to find call sites is to
rename the method and look for compilation fails.

Mozilla Analyses
================

`final.js`: Java-like `final` keyword for C++. If the thing is class/struct,
iterate the parents and if one has a `final`, error out. Use macro
`NS_FINAL_CLASS` to expand into GCC attribute.

`flow.js`: Ensure code in a function flows through a particular label. Use
label for cleanup code, but you might forget and `return` above it. Used in
SpiderMonkey (lots of really big methods) `MUST_FLOW_THROUGH("cleanup")`.

`must-override.js`: Force derived classes to override particular methods.

`override.js`: Ensure that methods exist in base class (warns if your
interface gets refactored).

`outparams.js`: Ensure outparameters and return error codes are in sync.

`stack.js`: Mark classes as stack-only (can't just make constructor private,
because it isn't used when it's a class member).

Shadow Variables
----------------

Warning present in Sun compiler, not GCC, MSVC. Found a bug in code, so
implemented as GCC plugin (for loop containing a few nested if statements).

Use `-fplugin=foo.so` and `-fplugin-arg=blah.js` to use the plugin and load
the analysis in Javascript.

Future
======

Only been deployed at Mozilla and a few other things.

It would be great if libraries could ship analyses which verify their use.

Increase the quality of open source software.

Increase dependence on GCC (and thus GCC).
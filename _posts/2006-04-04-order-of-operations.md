--- 
wordpressid: 1517
layout: post
title: Order of Operations
wordpressurl: http://passingcuriosity.com/2006/order-of-operations/
---
A recent experience reminded me of some posts on <a class="title" href="http://mathandtext.blogspot.com/">Math and Text</a>, a blog on mathematics education. <a class="title" href="http://mathandtext.blogspot.com/2005/12/so-long-aunt-sally.html">So Long, Aunt Sally!</a> discusses mnemonic devices for the order of operations (and reasons that such are a Bad Thing<sup>(TM)</sup>) and <a class="title" href="http://mathandtext.blogspot.com/2005/05/order-of-operations.html">Order of Operations</a> motivates the standard order of operations in terms of error reduction (performing those operations which will most effect the magnitude of the result first will reduce our error in the event that we've misread a number).<br /><br />Both of these posts interest me as I think that they both contain within them interesting insights to mathematics as seen by most of us (the non-mathematicians). The standard mathematical notation (that is, infix operators interpreted according to the standard order of operations) has a long history and is very much embedded with our understanding of maths. Unfortunately it is also rather poorly suited to expressing complex sentences: it requires that we interpret sentences with respect to a specific order of operations (exponentiation, multiplication/division, addition/subtraction) and use grouping operators (parentheses, brackets and the like).<br /><br />This shortcoming is, however, addressed in a class of expression languages called prefix and postfix languages. The difference between an infix language (like the standard mathematical notation), a prefix language and a postfix language is suggested by their names. An <b>in</b>fix language situates operators in-between their arguments, a <b>pre</b>fix language writes operators before their arguments and a in <b>post</b>fix language the operators follow their arguments. <br /><br />Where there is an ambiguity in infix languages as to which operators ought to be evaluated first (Left-to-right? Inward? Outward? According to precedence?), sentences of pre- and post-fix languages have only one possible interpretation. In these languages operations are performed in the order that they are written and we can express every sentence without using grouping operators (like brackets).<br /><br />In an infix language, the sentence "1+2*3" is ambiguous and can be parsed in two different ways: "(1+2)*3" and "1+(2*3)" (see <a href="#figure-1">figure 1</a>). Without a system of operator precedence, there is no way in which we can determine which of these two interpretations is "correct." In a pre- or post-fix language however, these two different interpretations are actually written differently. In postfix form, they can be written as "1 2 + 3 *" and "1 2 3 * +" respectively.<br /><br /><div style="font-size: 10pt; width: 60%; clear: both; margin-left: 15%; margin-right:15%;"><img style="cursor:pointer; cursor:hand;border:none;" src="http://photos1.blogger.com/blogger/5615/352/400/parsing.0.jpg" border="0" alt="" /><br /><a name="figure-1" style="font-weight: bold;">Figure 1</a>: Parse trees for the sentence "1+2*3" with main operator being + (left) and * (right). </div><br /><br />As they don't need an operator precedence scheme to determine which possible interpretation, these languages are much easier to parse and evaluate. This makes them ideal for use in constrained environment like calculators and printers. It is no surprise then, that many printers use the language Postscript to describe documents to be printed (with operators like draw-line and change colour, in addition to add and multiply) and some calculators use a programming language called RPN (though newer calculators also provide more complete languages). <br /><br />The algorithm for evaluating an expression is postfix form is: <ol><li>Read a token;</li><li>If it's a value push it onto the stack;</li><li>If it is an operator:<ol><li>Pop the appropriate number of arguments off the stack;</li><li>Perform the operation on those arguments; and</li> <li>Push the result of the operation onto the stack</li></ol></li> <li>Repeat until there is no more input and the answer will be the [single] item remaining on the stack.</li></ol>
